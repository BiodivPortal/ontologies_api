%div.container
  %div.row
    %div.span3
      %ul.nav.nav-list.bs-docs-sidenav.affix.sidebar-nav
        %li
          %a{href: "#nav_home"} Home
        %li
          %a{href: "#nav_usage"} General Usage
        %li
          %a{href: "#nav_search"} Search Endpoint
          %ul.nav.nav-list
            %li
              %a{href: "#nav_search_subtree"} Subtree Search
        %li
          %a{href: "#nav_annotator"} Annotator Endpoint
        %li
          %a{href: "#nav_recommender"} Recommender Endpoint
        %li
          %a{href: "#nav_resource_index"} Resource Index Endpoint
        %li
          %a{href: "#nav_batch"} Batch Endpoints
        %li
          %a{href: "#nav_resource_endpoints"} Resource Endpoints
          %ul.nav.nav-list
            %li
              %a{href: "#nav_media_types"} Media Types
              %ul.nav.nav-list
                -@metadata_all.each do |cls|
                  %li
                    %a{href: "#" + cls[1][:cls].name.split("::").last}= cls[1][:cls].name.split("::").last
        %li
          %a{href: "#nav_content_types"} Content Types


    %div.span9

      %h1#nav_home API Documentation
      %h2#nav_usage General Usage
      %p
        This API uses hypermedia to expose relationships between media types. The state of the application
        is driven by navigating these links.

      %h3 Common Parameters
      %table.table.table-striped.table-bordered
        %tr
          %th Parameter
          %th Possible Values
          %th Description
        %tr
          %td apikey
          %td {your api key}
          %td
            %p
              An API Key is required to access any API call. It can be provided in three ways:
              %ol
                %li Using the <code>apikey</code> query string parameter
                %li Providing an <code>Authorization</code> header: <code>Authorization: apikey token=your_apikey</code> (replace `your_apikey` with your actual key)
                %li When using a web browser to explore the API, if you provide your API Key once using method 1, it will be stored in a cookie for subsequent requests. You can override this by providing a different API Key in a new call.
        %tr
          %td include
          %td
            all<br/>
            {comma-separated list of attributes, EX: attr1,attr2}
          %td
            By default, the API will show a subset of the available attributes for a given media type.
            This behavior can be overridden by providing <code>include=all</code> to show all attributes
            or <code>include=attribute1,attribute2</code> to include a specific list. The API is optimized
            to return the default values, so overriding this can impact the performance of your request.
        %tr
          %td format
          %td
            json<br/>
            jsonp<br/>
            xml
          %td
            The API returns JSON as the default content type. This can be overridden by using the <code>format</code>
            query string parameter. The API also respects <code>Accept</code> header entries, with precedence given
            to the <code>format</code> parameter.
        %tr
          %td page
          %td {integer representing the page number}
          %td
            For calls that are paged, this will indicate which page number you want to retrieve.
            You can follow hypermedia links for <code>nextPage</code> and <code>prevPage</code> as well.
        %tr
          %td pagesize
          %td {integer representing the size of the returned page}
          %td For calls that are paged, this will indicate the size of the page you want to retrieve.
        %tr
          %td include_views
          %td {boolean representing whether or not to include ontology views (default is false)}
          %td For calls that involve ontologies, include_views='true' will include ontology views.

      %h2#nav_non_rest Search, Annotator, Recommender, and Resource Index Endpoints

      %p Several endpoints are available for performing lookups for classes, annotations, and annotated resources. These endpoints are not strictly RESTful, but do return objects with links where relevant.

      %h3#nav_search Classes Search

      %p
        An endpoint for searching classes and their properties is available
        %ul
          %li
            Perform search
          %ul
            %li
              <span class="label label-info">GET</span> <span class="label label-info">POST</span> <code>/search?q={search query}</code>
            %li
              example:
              %a{href: "/search?q=melanoma"} /search?q=melanoma
          %li
            Parameters
            %ul
              %li ontologies={ontology_id1,ontology_id2,ontology_id3}
              %li exact_match={true|false}  // default = false
              %li include_views={true|false}  // default = false
              %li require_definition={true|false}  // default = false
              %li include_properties={true|false}  // default = false

        %h4#nav_search_subtree Subtree Search

        %p
          The same endpoint also allows limiting a search to a given subtree/branch. The root of the subtree is defined using a combination of parameters "ontology" and "subtree_id". Both are required when performing a subtree search.
          %ul
            %li
              Perform a subtree search
            %ul
              %li
                example:
                %a{href: "/search?q=melanoma&ontology=NCIT&subtree_id=http%3a%2f%2fncicb.nci.nih.gov%2fxml%2fowl%2fEVS%2fThesaurus.owl%23C3224"} /search?q=melanoma&ontology=NCIT&subtree_id=http%3a%2f%2fncicb.nci.nih.gov%2fxml%2fowl%2fEVS%2fThesaurus.owl%23C3224
            %li
              Parameters
              %ul
                %li ontology={ontology_id}
                %li subtree_id={a URI encoded class id of the root node of the subtree}

      %h3#nav_annotator Annotator

      %p
        The Annotator endpoint will examine text input and return relevant classes. Currently, the annotator only returns direct annotations (hierarchy and mapping annoations are planned for a future release).
        %ul
          %li Annotate text
          %ul
            %li
              <span class="label label-info">GET</span> <span class="label label-info">POST</span> <code>/annotator?text={input text}</code>
            %li
              example:
              %a{href: "/annotator?text=Melanoma+is+a+malignant+tumor+of+melanocytes+which+are+found+predominantly+in+skin+but+also+in+the+bowel+and+the+eye."} /annotator?text=Melanoma+is+a+malignant+tumor+of+melanocytes+which+are+found+predominantly+in+skin+but+also+in+the+bowel+and+the+eye.
          %li
            Parameters
            %ul
              %li
                Filtering & query behavior
                %ul
                  %li ontologies={ontology_id1,ontology_id2..,ontology_idN}
                  %li semantic_types={semType1,semType2..,semTypeN}
                  %li max_level={0..N}
                  %li mapping_types={automatic|manual}
                  %li stop_words={word1,word2..,wordN}
                  %li minimum_match_length={0..N}

      %h3#nav_recommender Recommender

      %p
        The Recommender endpoint will call an Annotator API on a given text, and, based on the resulting annotations, group the ontologies from which the annotations came from according to their relevancy to the supplied text. The top results will contain ontologies with the highest relevancy scores. The Annotator is called with the max_level = 5 to include hierarchy matches in the relevancy calculation.
        %ul
          %li Recommend
          %ul
            %li
              <span class="label label-info">GET</span> <code>/recommender?text={input text}</code>
            %li
              example:
              %a{href: "/recommender?text=Melanoma+is+a+malignant+tumor+of+melanocytes+which+are+found+predominantly+in+skin+but+also+in+the+bowel+and+the+eye."} /recommender?text=Melanoma+is+a+malignant+tumor+of+melanocytes+which+are+found+predominantly+in+skin+but+also+in+the+bowel+and+the+eye.
          %li
            Parameters
            %ul
              %li
                Filtering & query behavior
                %ul
                  %li ontologies={ontology_id1,ontology_id2..,ontology_idN}
                  %li include_classes={true|false}  // default = false. Optionally to include the annotated classes in the output.

      %h3#nav_resource_index Resource Index

      %p
        The Resource Index contains a collection of annotated resources that can be searched by providing ontology acronyms with a corresponding class id or set of ids
        %ul
          %li
            Search
            %ul
              %li
                Single class
                %ul
                  %li
                    <span class="label label-info">GET</span> <code>/resource_index/search?classes[ontology_id1]=class_id1</code>
                  %li
                    example:
                    %a{href: "/resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003"} /resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003
                  %li
                    example (with short IDs):
                    %a{href: "/resource_index/search?classes[SNOMEDCT]=2092003"} /resource_index/search?classes[SNOMEDCT]=2092003
              %li
                Multiple classes, single ontology
                %ul
                  %li
                    <span class="label label-info">GET</span> <code>/resource_index/search?classes[ontology_id1]=class_id1,class_id2</code>
                  %li
                    example:
                    %a{href: "/resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003,http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F162573006"} /resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003,http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F162573006
                  %li
                    example (with short IDs):
                    %a{href: "/resource_index/search?classes[SNOMEDCT]=2092003,162573006"} /resource_index/search?classes[SNOMEDCT]=2092003,162573006
              %li
                Multiple classes, multiple ontologies
                %ul
                  %li
                    <span class="label label-info">GET</span> <code>/resource_index/search?classes[ontology_id1]=class_id1&classes[ontology_id2]=class_id1,class_id2</code>
                  %li
                    example:
                    %a{href: "/resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003&classes[NEMO]=http%3A%2F%2Fpurl.bioontology.org%2FNEMO%2Fontology%2FNEMO.owl%23NEMO_7571000"} /resource_index/search?classes[http%3A%2F%2Fdata.bioontology.org%2Fontologies%2FSNOMEDCT]=http%3A%2F%2Fpurl.bioontology.org%2Fontology%2FSNOMEDCT%2F2092003&classes[NEMO]=http%3A%2F%2Fpurl.bioontology.org%2FNEMO%2Fontology%2FNEMO.owl%23NEMO_7571000
                  %li
                    example (with short IDs):
                    %a{href: "/resource_index/search?classes[SNOMEDCT]=2092003&classes[NEMO]=NEMO:NEMO_7571000"} /resource_index/search?classes[SNOMEDCT]=2092003&classes[NEMO]=NEMO:NEMO_7571000
              %li
                Search Parameters
                %ul
                  %li
                    Filtering & query behavior
                    %ul
                      %li ontologies={ontology_id1,ontology_id2..,ontology_idN}
                      %li semantic_types={semType1,semType2..,semTypeN}
                      %li max_level={0..N}
                      %li mapping_types={automatic|manual}
                      %li resources={resource1,resource2..,resourceN}
                      %li exclude_numbers={true|false}
                      %li minimum_match_length={0..N}
                      %li include_synonyms={true|false}
                      %li mode={union|intersection}
                  %li
                    Stop words
                    %ul
                      %li stop_words={word1,word2..,wordN}
                      %li stop_words_are_case_sensitive={true|false}
          %li
            Ontologies
            %ul
              %li
                All ontologies:
              %li
                <span class="label label-info">GET</span> <code>/resource_index/ontologies</code>
              %li
                example:
                %a{href: "/resource_index/ontologies"} /resource_index/ontologies
          %li
            Resources
            %ul
              %li
                All resources:
                %ul
                  %li
                    <span class="label label-info">GET</span> <code>/resource_index/resources</code>
                  %li
                    example:
                    %a{href: "/resource_index/resources"} /resource_index/resources
              %li
                Specific resources:
                %ul
                  %li
                    <span class="label label-info">GET</span> <code>/resource_index/resources/{resource_id1,...,resource_idN}</code>
                  %li
                    example:
                    %a{href: "/resource_index/resources/AE"} /resource_index/resources/AE
                  %li
                    example:
                    %a{href: "/resource_index/resources/AE,CARY"} /resource_index/resources/AE,CARY


      %h2#nav_batch Batch Endpoints

      %p
        In order to reduce the number of HTTP requests required to obtain information about resources, we are exploring
        the use of batch endpoints that will use one request/response cycle for multiple resources. Currently, only
        classes are supported.

      %p
        :markdown
          <span class="label label-info">POST</span> <code>/batch</code>

          The batch service takes input in the BODY of a POST request. The input should be a JSON document with the following structure:

          <pre class="prettyprint linenums lang-javascript" style="display: table; padding-right: 20px;">
          {
              "http://www.w3.org/2002/07/owl#Class": {
                  "collection": [
                      {
                          "class": "http://example.org/ontology1/class1",
                          "ontology": "http://example.org/ontology1"
                      },
                      {
                          "class": "http://example.org/ontology2/class1",
                          "ontology": "http://example.org/ontology2"
                      },
                      {
                          "class": "http://example.org/ontologyN/classN",
                          "ontology": "http://example.org/ontologyN"
                      }
                  ],
                  "include": "prefLabel,synonym,semanticTypes"
              }
          }
          </pre>

          Example:

          <pre class="prettyprint linenums lang-javascript" style="display: table; padding-right: 20px;">
          {
              "http://www.w3.org/2002/07/owl#Class": {
                  "collection": [
                      {
                          "class": "http://bioontology.org/ontologies/BiomedicalResourceOntology.owl#Ontology_Development_and_Management",
                          "ontology": "http://data.bioontology.org/ontologies/BRO"
                      },
                      {
                        "class": "http://bioontology.org/ontologies/BiomedicalResourceOntology.owl#Modular_Component",
                          "ontology": "http://data.bioontology.org/ontologies/BRO"
                      },
                      {
                        "class": "http://bioontology.org/ontologies/BiomedicalResourceOntology.owl#Stimulator",
                          "ontology": "http://data.bioontology.org/ontologies/BRO"
                      }
                  ],
                  "include": "prefLabel,synonym,semanticTypes"
              }
          }
          </pre>


      %h2#nav_resource_endpoints Resource Endpoints

      %p
        Endpoints for RESTful resources can be found below, specifically in the list of Media Types.
        Using the provided hypermedia links, you can navigate from resource to resource.
        Each Media Type has a corresponding collection URL (when available), a list of HTTP verbs that can
        be used to operate on the resources, a description of the resource (including available attributes),
        and a list of hypermedia links that can be found on each resource.

      %h2#nav_media_types Media Types

      %h3 Documentation
      :markdown
        The documentation below describes the media types that available in the API. Media types describe the types of
        resources available, including the HTTP verbs that may be used with them and the attributes that each resource
        contains.

        #### HTTP Verbs
        The API uses different verbs to support processing of resources. This includes things like creating or deleting
        individual resources or something more specific like parsing an ontology. Typically, the verbs will be used in
        conjunciton with the URL that represents the id for a given resource. Here is how we interpret the verbs:

        - <span class="label label-info">GET</span> Used to retreive a resource or collection of resources.
        - <span class="label label-info">POST</span> Used to create a resource when the server determines the resource's id.
        - <span class="label label-info">PUT</span> Used to create a resource when a client determines the resource's id.
        - <span class="label label-info">PATCH</span> Used to modify an existing resource. The attributes in a PATCH request will replace existing attributes.
        - <span class="label label-info">DELETE</span> Used to delete an existing resource.

        #### Available Media Types
      %ol
        -@metadata_all.each do |cls|
          %li
            %a{href: "#" + cls[1][:cls].name.split("::").last}= cls[1][:uri]

      -@metadata_all.each do |cls, type|
        -@metadata = type
        =render(:haml, "documentation/metadata".to_sym)

      %h2#nav_content_types Content Types

      :markdown
        The API returns JSON as the default content type. This can be overridden by using the `format`
        query string parameter with the value `json`, `jsonp`, or `xml`. The API also respects `Accept` header entries
        (EX: `application/json`, `application/xml`), with precedence given to the `format` parameter.

        #### JSON
        The default content type is JSON, specifically a variant called [JSON-LD](http://json-ld.org/),
        or JSON Linked Data. You can treat this variant like normal JSON. All JSON parsers will be able
        to parse the output normally. The benefit of JSON-LD is that it enables hypermedia links, and you
        will find these links exposed as URLs in attributes labeled `@id`, which correspond to the id of the
        parent resource, or in an array called `links`, which contains a hash of link types with corresponding URLs.

        Here is a sample output of the JSON response format:
        <pre class="prettyprint linenums lang-javascript" style="display: table; padding-right: 20px;">
        {
            "administeredBy": [
                "http://data.bioontology.org/user/nevada"
            ],
            "acronym": "ABA-API-TST",
            "name": "ABA Adult Mouse Brain",
            "@id": "http://data.bioontology.org/ontology/ABA-API-TST",
            "@type": "http://data.bioontology.org/metadata/Ontology",
            "links": {
                "metrics": "http://data.bioontology.org/ontologies/ABA-API-TST/metrics",
                "submissions": "http://data.bioontology.org/ontologies/ABA-API-TST/submissions",
                "classes": "http://data.bioontology.org/ontologies/ABA-API-TST/classes",
                "roots": "http://data.bioontology.org/ontologies/ABA-API-TST/classes/roots",
                "reviews": "http://data.bioontology.org/ontologies/ABA-API-TST/reviews"
            },
            "@context": {
                "@vocab": "http://data.bioontology.org/metadata/",
                "acronym": "http://omv.ontoware.org/2005/05/ontology#acronym",
                "name": "http://omv.ontoware.org/2005/05/ontology#name",
                "administeredBy": {
                    "@id": "http://data.bioontology.org/metadata/User",
                    "@type": "@id"
                }
            }
        }
        </pre>

        - Line 7 shows the id for the resource. Doing an HTTP GET on the id will retreive the resource.
        - Line 8 shows the media type (see below).
        - Line 9 starts the links hash.
        - Line 16 is the resource's context, which can be used to determine the type for lists of ids. For example, line 2 lists
          the ids for users who administer the ontology, which can be determined by looking for the `administeredBy` attribute
          in the `@context` hash.
        - If you are interested in the predicate URI values used in the resource, these can be deterined by looking up the
          attribute in the `@context` hash or by appending the value of `@vocab` (line 17) to an attribute name in cases where
          the attribute isn't listed specifically in the `@context`.

        #### XML
        XML is also available as an alternative content type.

      %p Here is sample output for the XML format:
      <pre class="prettyprint linenums lang-xml" style="display: table; padding-right: 20px;">
      :escaped
        <ontology>
          <administeredByCollection>
            <administeredBy>http://data.bioontology.org/user/nevada</administeredBy>
          </administeredByCollection>
          <acronym>ABA-API-TST</acronym>
          <name>ABA Adult Mouse Brain</name>
          <id>http://data.bioontology.org/ontology/ABA-API-TST</id>
          <links>
            <self href="http://data.bioontology.org/ontology/ABA-API-TST" rel="http://data.bioontology.org/metadata/Ontology"/>
            <metrics href="/ontologies/ABA-API-TST/metrics"/>
            <submissions href="/ontologies/ABA-API-TST/submissions" rel="http://data.bioontology.org/metadata/OntologySubmission"/>
            <classes href="/ontologies/ABA-API-TST/classes" rel="http://www.w3.org/2002/07/owl#Class"/>
            <roots href="/ontologies/ABA-API-TST/classes/roots" rel="http://www.w3.org/2002/07/owl#Class"/>
            <reviews href="/ontologies/ABA-API-TST/reviews" rel="http://data.bioontology.org/metadata/Review"/>
          </links>
        </ontology>
      </pre>

      :markdown
        - Line 8 starts the links section
        - Lines 9-14 list links by type. The `href` attribute contains the link location and the `rel` attribute defines the type
          of resource that will be found at that location.
        - Elements outside of the links can also contain `href` and `rel` attributes (coming soon...)

